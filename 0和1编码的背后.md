# 0 和 1 编码的背后
## 二进制的一些基础知识
### 机器数和真值
1. 机器数
    一个数在计算机中的二进制表示形式，叫做这个数的机器数。机器数是带符号的，最高位存放一个符号位，非负数为 0，负数为 1。比如，十进制中的 +3，计算机字长为 8 位，转换成二进制就是 00000011。如果是 -3，就是 10000011。
2. 真值
    由于机器数的第一位是符号位，所以机器数的形式值不等于真正的数值。例如上面的有符号数 10000011，最高位是1，代表是负数，真正数值是 -3 而不是形式值 131。

### 原码，反码，补码
1. 原码
    原码就是符号位加上真值的绝对值，比如如果是 8 位二进制：
    ``` JavaScript
    [+1]原 = 0000 0001
    [-1]原 = 1000 0001
    ```
    第一位是符号位，所以 8 位二进制数的取值范围是：
    ``` JavaScript
    [1111 1111, 0111 1111] 即 [-127, 127]
    ```
2. 反码
    正数的反码是其本身，负数的反码是在其原码的基础上，符号位不变，其余各个位取反：
    ``` JavaScript
    [+1] = [0000 0001]原 = [0000 0001]反
    [-1] = [1000 0001]原 = [1111 1110]反
    ```

3. 补码
    正数的补码是其本身，负数的补码是在其原码的基础上，符号位不变，其余各位取反，最后 +1
    ```JavaScript
    [+1] = [0000 0001]原 = [0000 0001]反 = [0000 0001]补
    [-1] = [1000 0001]原 = [1111 1110]反 = [1111 1111]补
    ```

### 为何要使用原码，反码和补码
&emsp;&emsp;原码可以被人脑直接识别并用于计算表示方式，因为人脑计算时自动识别第一位的符号位，在计算时候根据符号位选择对真值区的加减。但是对于计算机，为了尽可能的设计简便，如果计算机“运算”还要额外考虑符号位是否参与运算，那基础的电路设计会变得更加复杂。根据运算法则，减去一个正数等于加上一个负数，即 1 + 1 = 1 + (-1) = 0，所以如果能符号位参与运算，那么四则运算里只用加法就能完成“加减”这两种运算了。

下面我们来看看 1 - 1 = 0，用这几种码符号位也参与运算的结果

``` JavaScript
1 + (-1) = [0000 0001]原 + [1000 0001]原 = [1000 0010]原 = -2

1 + (-1) = [0000 0001]反 + [1111 1110]反 = [1111 1111]反 = [1000 0000]原 = -0

1 + (-1) = [0000 0001]补 + [1111 1111]补 = [0000 0000]补 = [0000 0000]原 = 0
```

&emsp;&emsp;所有的运算结果都是正确的，只是原码的符号位参与运算似乎不符合我们的数值运算结果，反码的符号位参与运算产生了一个没有“意义”的 -0，补码的符号位参与运算不仅修复了 0 的符号问题，而且得到正确的结果，这背后不是偶然的随意反转数字得到的结果。

在补码运算结果仲，-1 - 127 结果应该是 -128, 用补码运算:

```JavaScript
-1 + (-127) = [1111 1111]补 + [1000 0001]补 = [1000 0000]补
```

&emsp;&emsp;在用补码运算的结果中，[1000 0000]补 就是 -128。但是注意因为实际上是实用以前的 -0 的补码来表示 -128，所以 -128并没有原码和反码表示。这就是为什么 8 位二进制，实用原码或反码表示的范围是 [-127, 127]，而实用补码表示的范围是 [-128, 127]，各位可以依次类推出 16 位、32 位、64 位的补码所能表示的范围。<sup><a href="#note1">[1]</a></sup>

## 二进制位运算
1. 按位与运算符（&）

运算规则：两位同时为“1”，结果才为“1”，否则为“0”。
```JavaScript
0 & 0 = 0;  0 & 1 = 0;  1 & 0 = 0;  1 & 1 = 1;
```

2. 按位或运算符（|）

运算规则：两位中有一位为“1”，结果为“1”，否则为“0”。
```JavaScript
0 | 0 = 0;  0 | 1 = 1;  1 | 0 = 1;  1 | 1 = 1;
```

3. 按位异或运算符（^）

运算规则：两位相同结果为“0”，不同结果为“1”。
```JavaScript
0 ^ 0 = 0;  0 ^ 1 = 1;  1 ^ 0 = 1;  1 ^ 1 = 0;
```
与 0 异或运算保留原值，与自身异或结果为 0。

4. 按位非运算符（~），也称作取反运算符

运算规则：一元运算符，自身的每一位取反。
```JavaScript
~1 = 0;  ~0 = 1;
```

5. 左移运算符（<<）

运算规则：将运算对象的各个二进制位全部左移若干位，左边二进制位丢弃，右边补 0。
```JavaScript
在 8 位二进制，数值 5 的二进制码是：0000 0101
5 << 2 结果是 10
0000 0101 << 2 结果是 0000 1010
```

6. 右移运算符（>>）

运算规则：将运算对象的各个二进制位全部右移若干位，正数左补 0， 负数左补 1，右边丢弃。
```JavaScript
在 8 位二进制，数值 5 的二进制原码是：0000 0101
5 >> 2 结果是 1
0000 0101 >> 2 结果是 0000 0001
```

7. 无符号右移运算符（>>>）

运算规则：将运算对象的各个二进制位全部右移若干位，右移后左边空出的位置补 0，移出右边的位丢弃。
```JavaScript
在 8 位二进制，数值 -5 的二进制原码是：1000 0101
-5 >>> 2 结果是 33
1000 0101 >>> 2 结果是 0010 0001
```

8. 不同长度的数据进行位运算

运算规则：如果两个不同长度的数据进行位运算，系统会将二者按右端对齐，然后进行位运算。对齐后左边不足的位依照下面三种情况补足
- 如果整型数据为正数，左边补 0。
- 如果整型数据为负数，左边补 1。
- 如果整型数据为无符号数，左边补 0。

## 逻辑运算符，又称为布尔运算符
1. 逻辑运算符，具有短路特性，进行逻辑与（&&）运算时会从左往右返回首先出现的 falsy 的值；逻辑或（||）则相反，会返回首先出现的 tury 的值。如果都能运算到最右边的值，结果则为最右的值。
``` JavaScript
例如：
let a = 1 && 2 && 3 && 0 && 4 && 5    //a = 0
let b = false || 0 || '' || 1 || null || undefined    //b = 1
```

2. 逻辑非运算符（！），进行取反运算。通常可对值进行 （！！）运算得到一个值的原始布尔值。


><a name="note1"></a> [[1]计算机为何能巧妙把符号位参与运算，将减法变成加法？](https://www.zhihu.com/question/30395946)